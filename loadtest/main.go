package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"sync"
	"time"
)

const (
	gatewayURL = "http://localhost:8080"
	adminEmail = "admin@careforall.com"
	adminPass  = "admin123"
	numUsers   = 20
)

type Stats struct {
	mu              sync.Mutex
	totalRequests   int64
	successRequests int64
	failedRequests  int64
	pledgesCreated  int64
	paymentsProcessed int64
	campaignsViewed int64
}

var stats = &Stats{}
var userTokens []string

func main() {
	fmt.Println("ðŸš€ CareForAll Load Testing Tool")
	fmt.Println("================================")
	fmt.Println("Starting continuous load generation...")
	fmt.Println("Press Ctrl+C to stop\n")

	// Get admin token
	adminToken, err := login(adminEmail, adminPass)
	if err != nil {
		log.Fatalf("Failed to get admin token: %v", err)
	}
	fmt.Printf("âœ“ Admin authenticated\n")

	// Initialize User Pool
	fmt.Printf("Creating pool of %d users...\n", numUsers)
	for i := 0; i < numUsers; i++ {
		email := fmt.Sprintf("loaduser-%d@loadtest.com", i)
		token, err := registerAndLogin(email, "TestPass123!")
		if err != nil {
			log.Printf("Failed to register user %d: %v", i, err)
			continue
		}
		userTokens = append(userTokens, token)
	}
	fmt.Printf("âœ“ User pool created (%d users)\n\n", len(userTokens))

	// Start stats reporter
	go reportStats()

	// Start multiple worker goroutines
	var wg sync.WaitGroup

	// 20 Workers that create pledges AND process payments (Full Flow)
	for i := 0; i < 20; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			donorWorker(workerID)
		}(i)
	}

	// 30 Workers that view campaigns (High Read Load)
	for i := 0; i < 30; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			campaignViewWorker(workerID)
		}(i)
	}

	// Worker that creates new campaigns occasionally
	wg.Add(1)
	go func() {
		defer wg.Done()
		campaignCreationWorker(adminToken)
	}()

	wg.Wait()
}

func donorWorker(workerID int) {
	if len(userTokens) == 0 {
		return
	}

	for {
		// Pick random user
		token := userTokens[rand.Intn(len(userTokens))]
		
		// Get random campaign (assuming IDs 1-5 exist mostly)
		campaignID := rand.Intn(5) + 1 
		amount := (rand.Intn(20) + 1) * 100 // $100 - $2000

		// 1. Create pledge
		pledgeID, err := createPledge(token, campaignID, amount)
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
			stats.pledgesCreated++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()

		if err == nil {
			// Simulate user entering payment details...
			time.Sleep(time.Duration(rand.Intn(500)+200) * time.Millisecond)

			// 2. Simulate Payment Webhook (Success)
			// In real life, user goes to payment gateway, pays, and gateway calls webhook
			err := simulatePaymentWebhook(pledgeID, "succeeded")

			stats.mu.Lock()
			stats.totalRequests++
			if err == nil {
				stats.successRequests++
				stats.paymentsProcessed++
			} else {
				stats.failedRequests++
			}
			stats.mu.Unlock()
		}

		// Sleep between 0.5 - 2 seconds
		time.Sleep(time.Duration(rand.Intn(1500)+500) * time.Millisecond)
	}
}

func campaignViewWorker(workerID int) {
	for {
		// View random campaign
		campaignID := rand.Intn(5) + 1
		
		// 50% chance to list all, 50% to view one
		var err error
		if rand.Float32() > 0.5 {
			err = getCampaign(campaignID)
		} else {
			err = listCampaigns()
		}
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
			stats.campaignsViewed++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()

		// Fast reads: 100ms - 500ms
		time.Sleep(time.Duration(rand.Intn(400)+100) * time.Millisecond)
	}
}

func campaignCreationWorker(adminToken string) {
	for {
		// Create a new campaign every 10-20 seconds
		time.Sleep(time.Duration(rand.Intn(10)+10) * time.Second)

		title := fmt.Sprintf("Load Test Campaign %d", time.Now().Unix())
		goalAmount := (rand.Intn(10) + 1) * 10000 

		err := createCampaign(adminToken, title, "Generated by load test", goalAmount)
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()
	}
}

func reportStats() {
	ticker := time.NewTicker(2 * time.Second)
	startTime := time.Now()
	
	for range ticker.C {
		stats.mu.Lock()
		total := stats.totalRequests
		success := stats.successRequests
		failed := stats.failedRequests
		pledges := stats.pledgesCreated
		payments := stats.paymentsProcessed
		views := stats.campaignsViewed
		stats.mu.Unlock()

		elapsed := time.Since(startTime).Seconds()
		rps := float64(total) / elapsed
		successRate := float64(0)
		if total > 0 {
			successRate = (float64(success) / float64(total)) * 100
		}

		fmt.Printf("\rðŸ”„ Req: %d | âœ“ OK: %d (%.1f%%) | âœ— Fail: %d | ðŸ’° Pledges: %d | ðŸ’¸ Paid: %d | ðŸ‘€ Views: %d | RPS: %.2f",
			total, success, successRate, failed, pledges, payments, views, rps)
	}
}


// API Functions

func login(email, password string) (string, error) {
	payload := map[string]string{
		"email":    email,
		"password": password,
	}
	
	body, _ := json.Marshal(payload)
	resp, err := http.Post(gatewayURL+"/auth/login", "application/json", bytes.NewBuffer(body))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("login failed: %d", resp.StatusCode)
	}

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	
	token, ok := result["token"].(string)
	if !ok {
		return "", fmt.Errorf("no token in response")
	}
	
	return token, nil
}

func registerAndLogin(email, password string) (string, error) {
	// Try to register
	payload := map[string]string{
		"email":    email,
		"password": password,
		"name":     "Load Test User",
	}
	
	body, _ := json.Marshal(payload)
	resp, err := http.Post(gatewayURL+"/auth/register", "application/json", bytes.NewBuffer(body))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	
	// If registration succeeded, return token
	if token, ok := result["token"].(string); ok && token != "" {
		return token, nil
	}
	
	// If registration failed, try login
	return login(email, password)
}

func createCampaign(token, title, description string, goalAmount int) error {
	payload := map[string]interface{}{
		"title":       title,
		"description": description,
		"goalAmount":  goalAmount,
	}
	
	body, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", gatewayURL+"/campaigns", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 && resp.StatusCode != 200 {
		return fmt.Errorf("campaign creation failed: %d", resp.StatusCode)
	}
	
	return nil
}

func createPledge(token string, campaignID, amount int) (int, error) {
	payload := map[string]interface{}{
		"campaignId": campaignID,
		"amount":     amount,
	}
	
	body, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", gatewayURL+"/pledges", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-Idempotency-Key", fmt.Sprintf("load-%d-%d", campaignID, time.Now().UnixNano()))
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 && resp.StatusCode != 200 {
		return 0, fmt.Errorf("pledge creation failed: %d", resp.StatusCode)
	}

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return 0, err
	}

	if id, ok := result["id"].(float64); ok {
		return int(id), nil
	}
	
	return 0, fmt.Errorf("could not parse pledge ID")
}

func simulatePaymentWebhook(pledgeID int, status string) error {
	payload := map[string]interface{}{
		"eventId":  fmt.Sprintf("evt_%d_%d", pledgeID, time.Now().UnixNano()),
		"pledgeId": pledgeID,
		"status":   status,
	}
	
	body, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", gatewayURL+"/payments/webhook", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("payment webhook failed: %d", resp.StatusCode)
	}
	
	return nil
}

func getCampaign(campaignID int) error {
	resp, err := http.Get(fmt.Sprintf("%s/campaigns/%d", gatewayURL, campaignID))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("campaign view failed: %d", resp.StatusCode)
	}
	
	return nil
}

func listCampaigns() error {
	resp, err := http.Get(gatewayURL + "/campaigns")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("list campaigns failed: %d", resp.StatusCode)
	}
	
	return nil
}

