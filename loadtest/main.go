package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"sync"
	"time"
)

const (
	gatewayURL = "http://localhost:8080"
	adminEmail = "admin@careforall.com"
	adminPass  = "admin123"
)

type Stats struct {
	mu              sync.Mutex
	totalRequests   int64
	successRequests int64
	failedRequests  int64
	pledgesCreated  int64
	campaignsViewed int64
}

var stats = &Stats{}

func main() {
	fmt.Println("ðŸš€ CareForAll Load Testing Tool")
	fmt.Println("================================")
	fmt.Println("Starting continuous load generation...")
	fmt.Println("Press Ctrl+C to stop\n")

	// Get admin token
	adminToken, err := login(adminEmail, adminPass)
	if err != nil {
		log.Fatalf("Failed to get admin token: %v", err)
	}
	fmt.Printf("âœ“ Admin authenticated\n\n")

	// Start stats reporter
	go reportStats()

	// Start multiple worker goroutines
	var wg sync.WaitGroup

	// Workers that create pledges (primary load)
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			pledgeWorker(workerID, adminToken)
		}(i)
	}

	// Workers that view campaigns
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			campaignViewWorker(workerID)
		}(i)
	}

	// Worker that creates new campaigns occasionally
	wg.Add(1)
	go func() {
		defer wg.Done()
		campaignCreationWorker(adminToken)
	}()

	// Worker that registers new users
	wg.Add(1)
	go func() {
		defer wg.Done()
		userRegistrationWorker()
	}()

	wg.Wait()
}

func pledgeWorker(workerID int, adminToken string) {
	// Register a unique user for this worker
	userEmail := fmt.Sprintf("donor-%d-%d@loadtest.com", workerID, time.Now().Unix())
	userToken, err := registerAndLogin(userEmail, "TestPass123!")
	if err != nil {
		log.Printf("Worker %d: Failed to get user token: %v", workerID, err)
		return
	}

	for {
		// Get random campaign
		campaignID := rand.Intn(4) + 1 // Campaigns 1-4
		amount := (rand.Intn(10) + 1) * 100 // $100 - $1000

		// Create pledge
		err := createPledge(userToken, campaignID, amount)
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
			stats.pledgesCreated++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()

		// Sleep between 1-5 seconds
		time.Sleep(time.Duration(rand.Intn(4)+1) * time.Second)
	}
}

func campaignViewWorker(workerID int) {
	for {
		// View random campaign
		campaignID := rand.Intn(4) + 1
		err := getCampaign(campaignID)
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
			stats.campaignsViewed++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()

		// Sleep between 0.5-2 seconds
		time.Sleep(time.Duration(rand.Intn(1500)+500) * time.Millisecond)
	}
}

func campaignCreationWorker(adminToken string) {
	for {
		// Create a new campaign every 30-60 seconds
		time.Sleep(time.Duration(rand.Intn(30)+30) * time.Second)

		title := fmt.Sprintf("Load Test Campaign %d", time.Now().Unix())
		goalAmount := (rand.Intn(10) + 1) * 10000 // $10k - $100k

		err := createCampaign(adminToken, title, "Generated by load test", goalAmount)
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()
	}
}

func userRegistrationWorker() {
	for {
		// Register new user every 10-20 seconds
		time.Sleep(time.Duration(rand.Intn(10)+10) * time.Second)

		email := fmt.Sprintf("user-%d@loadtest.com", time.Now().UnixNano())
		_, err := registerAndLogin(email, "TestPass123!")
		
		stats.mu.Lock()
		stats.totalRequests++
		if err == nil {
			stats.successRequests++
		} else {
			stats.failedRequests++
		}
		stats.mu.Unlock()
	}
}

func reportStats() {
	ticker := time.NewTicker(5 * time.Second)
	startTime := time.Now()
	
	for range ticker.C {
		stats.mu.Lock()
		total := stats.totalRequests
		success := stats.successRequests
		failed := stats.failedRequests
		pledges := stats.pledgesCreated
		views := stats.campaignsViewed
		stats.mu.Unlock()

		elapsed := time.Since(startTime).Seconds()
		rps := float64(total) / elapsed
		successRate := float64(0)
		if total > 0 {
			successRate = (float64(success) / float64(total)) * 100
		}

		fmt.Printf("\rðŸ”„ Requests: %d | âœ“ Success: %d (%.1f%%) | âœ— Failed: %d | ðŸ’° Pledges: %d | ðŸ‘€ Views: %d | RPS: %.2f",
			total, success, successRate, failed, pledges, views, rps)
	}
}

// API Functions

func login(email, password string) (string, error) {
	payload := map[string]string{
		"email":    email,
		"password": password,
	}
	
	body, _ := json.Marshal(payload)
	resp, err := http.Post(gatewayURL+"/auth/login", "application/json", bytes.NewBuffer(body))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("login failed: %d", resp.StatusCode)
	}

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	
	token, ok := result["token"].(string)
	if !ok {
		return "", fmt.Errorf("no token in response")
	}
	
	return token, nil
}

func registerAndLogin(email, password string) (string, error) {
	// Try to register
	payload := map[string]string{
		"email":    email,
		"password": password,
		"name":     "Load Test User",
	}
	
	body, _ := json.Marshal(payload)
	resp, err := http.Post(gatewayURL+"/auth/register", "application/json", bytes.NewBuffer(body))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	
	// If registration succeeded, return token
	if token, ok := result["token"].(string); ok && token != "" {
		return token, nil
	}
	
	// If registration failed, try login
	return login(email, password)
}

func createCampaign(token, title, description string, goalAmount int) error {
	payload := map[string]interface{}{
		"title":       title,
		"description": description,
		"goalAmount":  goalAmount,
	}
	
	body, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", gatewayURL+"/campaigns", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 && resp.StatusCode != 200 {
		return fmt.Errorf("campaign creation failed: %d", resp.StatusCode)
	}
	
	return nil
}

func createPledge(token string, campaignID, amount int) error {
	payload := map[string]interface{}{
		"campaignId": campaignID,
		"amount":     amount,
	}
	
	body, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", gatewayURL+"/pledges", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-Idempotency-Key", fmt.Sprintf("load-%d-%d", campaignID, time.Now().UnixNano()))
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 && resp.StatusCode != 200 {
		return fmt.Errorf("pledge creation failed: %d", resp.StatusCode)
	}
	
	return nil
}

func getCampaign(campaignID int) error {
	resp, err := http.Get(fmt.Sprintf("%s/campaigns/%d", gatewayURL, campaignID))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("campaign view failed: %d", resp.StatusCode)
	}
	
	return nil
}
